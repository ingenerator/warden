<?php
/**
 * Specify the behaviour of Model\User
 *
 * @author     Andrew Coulton <andrew@ingenerator.com>
 * @copyright  2013 inGenerator Ltd
 * @licence    BSD
 */

namespace spec\Model;

// Include the Kohana environment generated by koharness
require_once(__DIR__.'/../../koharness_bootstrap.php');

use PhpSpec\Exception\Example\FailureException;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

/**
 * Specify the behaviour of Model\User
 *
 * @package spec\Model
 * @see \Model\User
 * @see \Warden\Model\User
 */
class UserSpec extends ObjectBehavior
{

    public function it_is_initializable()
    {
        $this->shouldHaveType('Model\User');
    }

	/**
	 *
	 * @param \Warden\Hasher $hasher hasher implementation
	 *
	 * @throws \PhpSpec\Exception\Example\FailureException
	 */
	public function it_hashes_the_password_for_storage($hasher)
	{
		$hasher->hash('foo-password')
		    ->shouldBeCalled();
		$this->hasher($hasher);

		$this->set_password('foo-password');
	}

	public function it_does_not_store_the_cleartext_password_anywhere()
	{
		$this->set_password('foo-password');

		// A workaround as the class does not need to expose the hash in the public API but we want to double check this
		$serialised = serialize($this->getWrappedObject());
		if (\strpos($serialised, 'foo-password'))
		{
			throw new FailureException("Expected the class not to store the cleartext password, but it does");
		}
	}

	/**
	 * Note that this specification uses the real hasher implementation rather than a mock as a safety net against
	 * edge cases and because it is simpler than making reference to the protected password_hash property
	 */
	public function it_verifies_a_password_against_the_stored_hash_and_returns_true_if_matching()
	{
		$this->set_password('foo-password');
		$this->verify_password('foo-password')->shouldReturn(TRUE);
		$this->verify_password('something-else')->shouldReturn(FALSE);
	}

	/**
	 *
	 * @param \Warden\Hasher $hasher hasher mock
	 */
	public function it_verifies_and_upgrades_old_password_hashes_if_required($hasher)
	{
		$hasher->verify('foo-password', Argument::any())->willReturn(TRUE);
		$hasher->needs_rehash(Argument::any())->willReturn(TRUE);

		$this->hasher($hasher);

		$hasher->hash('foo-password')->shouldBeCalled();

		$this->verify_password('foo-password')->shouldReturn(\Model\User::PASSWORD_OK_UPGRADED);
	}

	/**
	 *
	 * @param \Warden\Hasher $hasher hasher mock
	 */
	public function it_verifies_but_does_not_upgrade_password_hashes_that_are_ok($hasher)
	{
		$hasher->verify('foo-password', Argument::any())->willReturn(TRUE);
		$hasher->needs_rehash(Argument::any())->willReturn(FALSE);
		$this->hasher($hasher);

		$this->verify_password('foo-password')->shouldReturn(TRUE);

		$hasher->hash(Argument::any())->shouldNotBeenCalled();
	}

	/**
	 *
	 * @param \Warden\Hasher $hasher hasher mock
	 */
	public function it_verifies_but_does_not_upgrade_hashes_if_password_is_wrong($hasher)
	{
		$hasher->verify('foo-password', Argument::any())->willReturn(FALSE);
		$hasher->needs_rehash(Argument::any())->willReturn(TRUE);
		$this->hasher($hasher);

		$this->verify_password('foo-password')->shouldReturn(FALSE);

		$hasher->hash(Argument::any())->shouldNotBeenCalled();
	}

}
